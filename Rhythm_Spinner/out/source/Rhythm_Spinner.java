/* autogenerated by Processing revision 1293 on 2023-12-14 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.awt.event.KeyEvent;
import java.lang.Runnable;
import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Rhythm_Spinner extends PApplet {





//Position of the center of the screen (for easy alignment)
final PVector screenCenter = new PVector(640, 512);

//Central spinner for rhythm game
Spinner spinner = new Spinner();

//Sound effects
SoundFile buttonClickFX;
SoundFile noteHitFX;

//Song audio files
SoundFile topOfTheWaveFile;
SoundFile cloudsFile;
SoundFile tonightFile;
SoundFile sunriseFile;

//Song charts
Note[] topOfTheWaveChart;
Note[] cloudsChart;
Note[] tonightChart;
Note[] sunriseChart;

//Song cover images
PImage topOfTheWaveCover;
PImage cloudsCover;
PImage tonightCover;
PImage sunriseCover;

//Songs
Song topOfTheWave;
Song clouds;
Song tonight;
Song sunrise;

//How far off the beat the player can be to still hit a note perfectly (in beats)
final float tolerance = 0.15f;

//Volume values
float musicVolume = 1;
float sfxVolume = 1;

//Score and accuracy, reset on each play
int score = 0;
float accuracy;

//Array for storing the confetti in the S-rank confetti effect
Confetti[] confettiEffect;

//Array for storing all currently displaying timing indicators
ArrayList<TempText> timingIndicators = new ArrayList<TempText>();

//Scene manager, for keeping track of the current scene
SceneManager sceneManager = new SceneManager(new Scene[7]);

//Button layouts of each menu
Button[][] startMenuButtons = {{new Button(new PVector(screenCenter.x, 432), new PVector(640, 160), 0xFFFF9696, 0xFFFF96FF, "START", () -> sceneManager.setScene("Song-Select"))},
                               {new Button(new PVector(screenCenter.x, 656), new PVector(640, 160), 0xFFFF9696, 0xFFFF96FF, "OPTIONS", () -> sceneManager.setScene("Options-Menu"))},
                               {new Button(new PVector(screenCenter.x, 880), new PVector(640, 160), 0xFFFF9696, 0xFFFF96FF, "EXIT", () -> exit())}};

Button[][] songSelectButtons = {{new Button(new PVector(928, 128), new PVector(704, 128), 0xFFFF9696, 0xFFFF96FF, "", () -> {
                                    Conductor.setSong(topOfTheWave);
                                    sceneManager.setScene("Main-Game");
                                    Conductor.playSong();
                                    score = 0;
                                })},
                                {new Button(new PVector(928, 320), new PVector(704, 128), 0xFFFF9696, 0xFFFF96FF, "", () -> {})},
                                {new Button(new PVector(928, 512), new PVector(704, 128), 0xFFFF9696, 0xFFFF96FF, "", () -> {
                                    Conductor.setSong(clouds);
                                    sceneManager.setScene("Main-Game");
                                    Conductor.playSong();
                                    score = 0;
                                })},
                                {new Button(new PVector(928, 704), new PVector(704, 128), 0xFFFF9696, 0xFFFF96FF, "", () -> {
                                    Conductor.setSong(tonight);
                                    sceneManager.setScene("Main-Game");
                                    Conductor.playSong();
                                    score = 0;
                                })},
                                {new Button(new PVector(928, 896), new PVector(704, 128), 0xFFFF9696, 0xFFFF96FF, "", () -> {
                                    Conductor.setSong(sunrise);
                                    sceneManager.setScene("Main-Game");
                                    Conductor.playSong();
                                    score = 0;
                                })}};

Button[][] optionsMenuButtons = {{new Button(new PVector(352, 224), new PVector(128, 64), 0xFFFF9696, 0xFFFF96FF, "0%", () -> musicVolume = 0),
                                  new Button(new PVector(544, 224), new PVector(128, 64), 0xFFFF9696, 0xFFFF96FF, "25%", () -> musicVolume = 0.25f),
                                  new Button(new PVector(736, 224), new PVector(128, 64), 0xFFFF9696, 0xFFFF96FF, "50%", () -> musicVolume = 0.5f),
                                  new Button(new PVector(928, 224), new PVector(128, 64), 0xFFFF9696, 0xFFFF96FF, "75%", () -> musicVolume = 0.75f),
                                  new Button(new PVector(1120, 224), new PVector(128, 64), 0xFFFF9696, 0xFFFF96FF, "100%", () -> musicVolume = 1)},
                                 {new Button(new PVector(352, 320), new PVector(128, 64), 0xFFFF9696, 0xFFFF96FF, "0%", () -> sfxVolume = 0),
                                  new Button(new PVector(544, 320), new PVector(128, 64), 0xFFFF9696, 0xFFFF96FF, "25%", () -> sfxVolume = 0.25f),
                                  new Button(new PVector(736, 320), new PVector(128, 64), 0xFFFF9696, 0xFFFF96FF, "50%", () -> sfxVolume = 0.5f),
                                  new Button(new PVector(928, 320), new PVector(128, 64), 0xFFFF9696, 0xFFFF96FF, "75%", () -> sfxVolume = 0.75f),
                                  new Button(new PVector(1120, 320), new PVector(128, 64), 0xFFFF9696, 0xFFFF96FF, "100%", () -> sfxVolume = 1)},
                                 {null,
                                  null,
                                  null,
                                  new Button(new PVector(928, 544), new PVector(192, 64), 0xFFFF9696, 0xFFFF96FF, "Change", () -> sceneManager.setScene("Button-Change-Select")),
                                  null},
                                 {null,
                                  null,
                                  null,
                                  new Button(new PVector(928, 672), new PVector(192, 64), 0xFFFF9696, 0xFFFF96FF, "Change", () -> sceneManager.setScene("Button-Change-Back")),
                                  null}};

//Menus for each scene
Menu startMenu = new Menu(startMenuButtons);
Menu songSelectMenu = new Menu(songSelectButtons);
Menu optionsMenu = new Menu(optionsMenuButtons);

//Scenes
Scene startMenuScene = new Scene("Start-Menu", () -> {}, () -> {
    //DRAW FUNCTION
    //Draw menu
    startMenu.draw();

    //Draw Title
    textAlign(CENTER, CENTER);
    textSize(96);
    text("RHYTHM SPINNER!", screenCenter.x, 160, 1088, 192);
    textSize(32);
}, () -> {
    //KEY PRESSED FUNCTION
    //Update menu
    startMenu.changeSelection(keyCode);
    if(keyCode == InputManager.selectButton) {
        startMenu.selectedButton.press();
    }
});

Scene songSelectScene = new Scene("Song-Select", () -> {}, () -> {
    //DRAW FUNCTION
    //Draw menu
    songSelectMenu.draw();

    //Draw songs titles and artists on buttons
    textAlign(LEFT, CENTER);
    text(topOfTheWave.title, 1024, 96, 512, 64);
    text(topOfTheWave.artist, 1024, 160, 512, 64);
    text("", 1024, 288, 512, 64);
    text("", 1024, 352, 512, 64);
    text(clouds.title, 1024, 480, 512, 64);
    text(clouds.artist, 1024, 544, 512, 64);
    text(tonight.title, 1024, 672, 512, 64);
    text(tonight.artist, 1024, 736, 512, 64);
    text(sunrise.title, 1024, 864, 512, 64);
    text(sunrise.artist, 1024, 928, 512, 64);

    //Draw song difficult on buttons
    textAlign(CENTER, CENTER);
    text("6", 640, 128, 128, 128);
    text("N", 640, 320, 128, 128);
    text("9", 640, 512, 128, 128);
    text("3", 640, 704, 128, 128);
    text("7", 640, 896, 128, 128);

    //Display song info based on selected song
    switch(songSelectMenu.selectedIndex.i) {
        case 0:
            image(topOfTheWave.cover, 288, 288, 288, 288);
            text(topOfTheWave.title, 288, 576, 384, 64);
            text(topOfTheWave.artist, 288, 656, 384, 64);
            text("6/10", 288, 736, 384, 64);
            text(topOfTheWave.bpm + " BPM", 288, 816, 384, 64);
            break;
        
        case 1:
            text("", 288, 576, 384, 64);
            text("", 288, 656, 384, 64);
            text("N/10", 288, 736, 384, 64);
            text("" + " BPM", 288, 816, 384, 64);
            break;

        case 2:
            image(clouds.cover, 288, 288, 288, 288);
            text(clouds.title, 288, 576, 384, 64);
            text(clouds.artist, 288, 656, 384, 64);
            text("9/10", 288, 736, 384, 64);
            text(clouds.bpm + " BPM", 288, 816, 384, 64);
            break;

        case 3:
            image(tonight.cover, 288, 288, 288, 288);
            text(tonight.title, 288, 576, 384, 64);
            text(tonight.artist, 288, 656, 384, 64);
            text("3/10", 288, 736, 384, 64);
            text(tonight.bpm + " BPM", 288, 816, 384, 64);
            break;

        case 4:
            image(sunrise.cover, 288, 288, 288, 288);
            text(sunrise.title, 288, 576, 384, 64);
            text(sunrise.artist, 288, 656, 384, 64);
            text("7/10", 288, 736, 384, 64);
            text(sunrise.bpm + " BPM", 288, 816, 384, 64);
            break;
    }
}, () -> {
    //KEY PRESSED FUNCTION
    //Update menu
    songSelectMenu.changeSelection(keyCode);
    if(keyCode == InputManager.selectButton) {
        songSelectMenu.selectedButton.press();
    }
    if(keyCode == InputManager.backButton) {
        sceneManager.setScene("Start-Menu");
    }
});

Scene optionsMenuScene = new Scene("Options-Menu", () -> {}, () -> {
    //DRAW FUNCTION
    //Draw menu
    optionsMenu.draw();

    //Draw menu titles
    textAlign(CENTER, CENTER);
    text("Volume", screenCenter.x, 96, 512, 96);
    text("Controls", screenCenter.x, 416, 512, 96);

    textAlign(LEFT, CENTER);
    text("Music: " + musicVolume * 100 + "%", 144, 224, 256, 64);
    text("SFX: " + sfxVolume * 100 + "%", 144, 320, 256, 64);
    text("Select: " + InputManager.selectButton, 144, 544, 256, 64);
    text("Back: " + InputManager.backButton, 144, 672, 256, 64);
}, () -> {
    //KEY PRESSED FUNCTION
    //Update menu
    optionsMenu.changeSelection(keyCode);
    if(keyCode == InputManager.selectButton) {
        optionsMenu.selectedButton.press();
    }
    if(keyCode == InputManager.backButton) {
        sceneManager.setScene("Start-Menu");
    }
});

Scene buttonChangeSelectScene = new Scene("Button-Change-Select", () -> {}, () -> {
    //DRAW FUNCTION
    //Draw info text
    textAlign(CENTER, CENTER);
    text("Press button to set as select button", screenCenter.x, screenCenter.y, 256, 256);
}, () -> {
    //KEY PRESSED FUNCTION
    //Make pressed button the select button
    InputManager.selectButton = keyCode;
    buttonClickFX.play();
    sceneManager.setScene("Options-Menu");
});

Scene buttonChangeBackScene = new Scene("Button-Change-Back", () -> {}, () -> {
    //DRAW FUNCTION
    //Draw info text
    textAlign(CENTER, CENTER);
    text("Press button to set as back button", screenCenter.x, screenCenter.y, 256, 256);
}, () -> {
    //KEY PRESSED FUNCTION
    //Make pressed button the back button
    InputManager.backButton = keyCode;
    buttonClickFX.play();
    sceneManager.setScene("Options-Menu");
});

Scene mainGameScene = new Scene("Main-Game", () -> {
    //UPDATE FUNCTION
    //Update objects
    spinner.update();
    Conductor.update();
    if(Conductor.chart != null) {
        for(Note note : Conductor.chart) {
            note.update();
        }
    }

    //Tick timing indicators
    //I finally found a use for a while loop that isn't vile and disgusting!!!!
    int counter = 0;
    while(counter < timingIndicators.size()) {
        timingIndicators.get(counter).tick();
        if(timingIndicators.get(counter).timer < 0) {
            timingIndicators.remove(counter);
        } else {
            counter++;
        }
    }

    //Remove missed notes
    for(int i = 0; i < Conductor.chart.size(); i++) {
        while(true) {
            if(Conductor.chart.size() <= 0) {
                break;
            }
            if(Conductor.songPosition > Conductor.chart.get(i).beat + tolerance * 2) {
                timingIndicators.add(new TempText(Conductor.chart.get(i).position, "Miss"));
                Conductor.chart.remove(i);
            } else {
                break;
            }
        }
    }

    //Go to results screen if song is over
    if(!Conductor.songFile.isPlaying() && !Conductor.inCountIn) {
        sceneManager.setScene("Results");
        accuracy = (float) score / (Conductor.songData.chart.length * 100);
        if(accuracy > 0.95f) {
            confettiEffect = new Confetti[25];
            for(int i = 0; i < confettiEffect.length; i++) {
                confettiEffect[i] = new Confetti();
            }
        }
    }
}, () -> {
    //DRAW FUNCTION
    //Draw spinner
    spinner.draw();
    
    //Draw notes
    for(Note note : Conductor.chart) {
        note.draw();
    }

    //Draw timing indicators
    for(TempText text : timingIndicators) {
        text.draw();
    }

    //Draw song info
    textAlign(LEFT, CENTER);
    fill(0);
    text(score + "", 288, 64, 256, 64);
    text(Conductor.songData.title, 288, 864, 256, 64);
    text(Conductor.songData.artist, 288, 928, 256, 64);
}, () -> {
    //KEY PRESSED FUNCTION
    //If an arcade button is pressed, check if a note has been hit
    if(InputManager.isArcadeButton(keyCode)) {
        for(int i = 0; i < Conductor.chart.size(); i++) {
            if(Conductor.chart.get(i).beat < Conductor.songPosition + tolerance &&
               Conductor.chart.get(i).beat > Conductor.songPosition - tolerance &&
               Conductor.chart.get(i).lane == spinner.selectedSegment) {
                //Perfect judgement
                timingIndicators.add(new TempText(Conductor.chart.get(i).position, "Perfect!"));
                Conductor.chart.remove(i);
                score += 100;
                noteHitFX.play();
                break;
            } else if(Conductor.chart.get(i).beat < Conductor.songPosition + tolerance * 2 &&
               Conductor.chart.get(i).beat > Conductor.songPosition &&
               Conductor.chart.get(i).lane == spinner.selectedSegment) {
                //Early judgement
                timingIndicators.add(new TempText(Conductor.chart.get(i).position, "Early"));
                Conductor.chart.remove(i);
                score += 50;
                noteHitFX.play();
                break;
            } else if(Conductor.chart.get(i).beat < Conductor.songPosition &&
               Conductor.chart.get(i).beat > Conductor.songPosition - tolerance * 2 &&
               Conductor.chart.get(i).lane == spinner.selectedSegment) {
                //Late judgement
                timingIndicators.add(new TempText(Conductor.chart.get(i).position, "Late"));
                Conductor.chart.remove(i);
                score += 50;
                noteHitFX.play();
                break;
            } else if(Conductor.chart.get(i).beat < Conductor.songPosition + tolerance * 3 &&
               Conductor.chart.get(i).beat > Conductor.songPosition &&
               Conductor.chart.get(i).lane == spinner.selectedSegment) {
                //Miss judgement
                timingIndicators.add(new TempText(Conductor.chart.get(i).position, "Miss"));
                Conductor.chart.remove(i);
                break;
            }
        }
    }
});

Scene resultsScene = new Scene("Results", () -> {
    //UPDATE FUNCTION
    //Update confetti
    if(confettiEffect != null) {
        for(Confetti confetti : confettiEffect) {
            confetti.move();
        }
    }
}, () -> {
    //DRAW FUNCTION
    //Draw confetti
    if(confettiEffect != null) {
        for(Confetti confetti : confettiEffect) {
            confetti.draw();
        }
    }

    //Draw grade
    textAlign(CENTER, CENTER);
    String grade;
    int gradeColor;
    if(accuracy < 0.7f) {
        grade = "F";
        gradeColor = 0xFF404040;
    } else if(accuracy < 0.8f) {
        grade = "D";
        gradeColor = 0xFFFF50FF;
    } else if(accuracy < 0.85f) {
        grade = "C";
        gradeColor = 0xFF5050FF;
    } else if(accuracy < 0.9f) {
        grade = "B";
        gradeColor = 0xFF50FFFF;
    } else if(accuracy < 0.95f) {
        grade = "A";
        gradeColor = 0xFF50FF50;
    } else {
        grade = "S";
        gradeColor = 0xFFA0FF50;
    }
    textSize(128);
    fill(gradeColor);
    text(grade, screenCenter.x, 352, 128, 128);

    //Draw score and accuracy
    textSize(32);
    fill(0);
    text(score + "", screenCenter.x, 576, 256, 64);
    text(accuracy * 100 + "%", screenCenter.x, 672, 256, 64);
}, () -> {
    //KEY PRESSED FUNCTION
    //Exit screen when a button is pressed
    if(InputManager.isArcadeButton(keyCode)) {
        sceneManager.setScene("Song-Select");
        confettiEffect = null;
    }
});

public void setup() {
    //Setup screen
    /* size commented out by preprocessor */;

    //Add scenes to scene manager
    sceneManager.scenes[0] = startMenuScene;
    sceneManager.scenes[1] = songSelectScene;
    sceneManager.scenes[2] = optionsMenuScene;
    sceneManager.scenes[3] = buttonChangeSelectScene;
    sceneManager.scenes[4] = buttonChangeBackScene;
    sceneManager.scenes[5] = mainGameScene;
    sceneManager.scenes[6] = resultsScene;

    //Set display modes
    rectMode(CENTER);
    imageMode(CENTER);
    ellipseMode(RADIUS);
    textSize(32);

    //Load sound files
    buttonClickFX = new SoundFile(this, "SFX/mixkit-single-classic-click-1116.wav");
    noteHitFX = new SoundFile(this, "SFX/Hi-Hat-Closed-Hit-C2-www.fesliyanstudios.com.wav");
    topOfTheWaveFile = new SoundFile(this, "Songs/Top-of-the-Wave-(Vlad-Gluschenko)/vlad-gluschenko-top-of-the-wave.wav");
    cloudsFile = new SoundFile(this, "Songs/Clouds-(MusicbyAden)/musicbyaden-clouds.wav");
    tonightFile = new SoundFile(this, "Songs/tonight-(Rexlambo)/rexlambo-tonight.wav");
    sunriseFile = new SoundFile(this, "Songs/Sunrise-(LiQWYD)/liqwyd-sunrise.wav");

    //Load charts
    JSONObject waveJSON = loadJSONObject("Songs/Top-of-the-Wave-(Vlad-Gluschenko)/chart.json");
    JSONObject cloudsJSON = loadJSONObject("Songs/Clouds-(MusicbyAden)/chart.json");
    JSONObject tonightJSON = loadJSONObject("Songs/tonight-(Rexlambo)/chart.json");
    JSONObject sunriseJSON = loadJSONObject("Songs/Sunrise-(LiQWYD)/chart.json");
    
    //Convert charts
    topOfTheWaveChart = loadChartFromJSON(waveJSON);
    cloudsChart = loadChartFromJSON(cloudsJSON);
    tonightChart = loadChartFromJSON(tonightJSON);
    sunriseChart = loadChartFromJSON(sunriseJSON);

    //Load images
    topOfTheWaveCover = loadImage("Songs/Top-of-the-Wave-(Vlad-Gluschenko)/vlad-gluschenko-top-of-the-wave.jpg");
    cloudsCover = loadImage("Songs/Clouds-(MusicbyAden)/musicbyaden-clouds.jpg");
    tonightCover = loadImage("Songs/tonight-(Rexlambo)/rexlambo-tonight.jpg");
    sunriseCover = loadImage("Songs/Sunrise-(LiQWYD)/liqwyd-sunrise.jpg");

    //Initialize songs
    topOfTheWave = new Song(126, -1.2f, 2.5f, topOfTheWaveFile, topOfTheWaveChart, "Top of the Wave", "Vlad Gluschenko", topOfTheWaveCover);
    clouds = new Song(120, 0, 4, cloudsFile, cloudsChart, "Clouds", "MusicbyAden", cloudsCover);
    tonight = new Song(128, 0.19f, 4, tonightFile, tonightChart, "tonight", "Rexlambo", tonightCover);
    sunrise = new Song(115, 2.12f, 0, sunriseFile, sunriseChart, "Sunrise", "LiQWYD", sunriseCover);

    //Set starting scene
    sceneManager.setStartingScene();
}

public void draw() {
    //Clear screen
    background(255);
    
    //Set time for conductor (necesary because millis() isn't a static method for some reason, so the compiler throws a fit)
    Conductor.curTime = (float) millis() / 1000;

    //Update current scene
    sceneManager.currentScene.update();

    //Set sound file volumes
    buttonClickFX.amp(sfxVolume);
    noteHitFX.amp(sfxVolume);
    topOfTheWaveFile.amp(musicVolume);
    cloudsFile.amp(musicVolume);
    tonightFile.amp(musicVolume);

    //Draw current scene
    sceneManager.currentScene.draw();
}

public void keyPressed() {
    //Update inputs
    InputManager.addKey(keyCode);

    //Run the current scene's keyPressed function
    sceneManager.currentScene.keyPressed();
}

public void keyReleased() {
    //Update inputs
    InputManager.removeKey(keyCode);

    //Run the current scene's keyReleased function
    sceneManager.currentScene.keyReleased();
}

/**
* Load Chart from JSON function
* Takes a chart JSON object and returns an array of notes
*
* @param JSONObject for chart to be loaded from
* @return Array of notes in the chart, or null if the JSONObject isn't a chart
*/
public Note[] loadChartFromJSON(JSONObject json) {
    JSONArray chart;
    try {
        chart = json.getJSONArray("chart");
    } catch(Exception e) {
        println("Object is not a chart");
        return null;
    }
    Note[] output = new Note[chart.size()];
    for(int i = 0; i < chart.size(); i++) {
        output[i] = new Note(chart.getJSONObject(i).getInt("lane"), chart.getJSONObject(i).getFloat("beat"));
    }
    return output;
}
/**
* Button class
* Stores all attributes related to UI buttons
*/
class Button {
    //Parameters of the rectangle representing the button
    private PVector position;
    private PVector size;

    //Color of the button when not selected
    private int baseColor;
    //Color of the button when selected
    private int selectedColor;

    //Text to be displayed on the button
    private String label;

    //Function to be called when the button is pressed
    private Runnable onPressedFunction;

    public Button(PVector position, PVector size, int baseColor, int selectedColor, String label, Runnable onPressedFunction) {
        this.position = position;
        this.size = size;
        this.baseColor = baseColor;
        this.selectedColor = selectedColor;
        this.label = label;
        this.onPressedFunction = onPressedFunction;
    }

    /**
    * Draw method
    * Draws the button
    * Changes color based on whether or not the button is selected
    *
    * @param Whether or not the button is currently selected
    */
    public void draw(boolean selected) {
        if(selected) {
            fill(this.selectedColor);
        } else {
            fill(this.baseColor);
        }
        rect(this.position.x, this.position.y, this.size.x, this.size.y);
        fill(0);
        textAlign(CENTER, CENTER);
        text(this.label, this.position.x, this.position.y, this.size.x, this.size.y);
    }

    /**
    * Press method
    * Calls the button's on pressed function
    */
    public void press() {
        this.onPressedFunction.run();
        buttonClickFX.play();
    }
}
/**
* Conductor class
* Controls timing for rhythm elements
* Taken from https://www.reddit.com/r/gamedev/comments/2fxvk4/heres_a_quick_and_dirty_guide_i_just_wrote_how_to/
*/
static class Conductor {
    //Beat per minute of the song currently being played
    private static int bpm;
    //Length of a beat of the song currently being played (in seconds)
    private static float crotchet;
    //Time before the song actually starts in the audio file (to account for space required for metadata) (in seconds)
    private static float offset;

    //Time to wait before starting the song (in beats)
    private static float countIn;
    //Time at which the song began playing (start of count in) (in seconds)
    private static float startTime;
    //The current program time (in seconds)
    public static float curTime;


    //Position in the current song (in beats)
    public static float songPosition;
    //Audio file for the song currently being played
    public static SoundFile songFile;
    //Song object of the song currently being played, for accessing extra information
    public static Song songData;

    //A copy of the chart of the current song (must be a copy, as notes will be removed from this version during runtime)
    public static ArrayList<Note> chart = new ArrayList<Note>();

    //Whether or not the song is currently in count in, to ensure songs don't end before they start
    public static boolean inCountIn = false;

    /**
    * Update method
    * Updates the conductor
    */
    public static void update() {
        if(songFile != null) {
            if(inCountIn) {
                if(!songFile.isPlaying() && curTime - startTime > countIn * crotchet) {
                    //End count in, start playing the song
                    songFile.play();
                    inCountIn = false;
                }

                //Set song position
                songPosition = ((curTime - startTime) / crotchet) - countIn - (offset / crotchet);
            } else {
                //Update song position
                songPosition = (songFile.position() - offset) / crotchet;
            }
        }
    }

    /**
    * Set Song method
    * Sets the current song being played
    *
    * @param song to be played
    */
    public static void setSong(Song song) {
        bpm = song.bpm;
        crotchet = (float) 60 / song.bpm;
        offset = song.offset;
        countIn = song.countIn;
        songFile = song.songFile;
        songData = song;
        chart.clear();
        for(Note note : song.chart) {
            chart.add(note);
        }
    }

    /**
    * Play Song method
    * Begins playing the current song
    */
    public static void playSong() {
        if(!inCountIn && songFile != null) {
            startTime = curTime;
            inCountIn = true;
        }
    }
}
/**
* Confetti class
* Stores values relating to a piece of confetti
*/
class Confetti {
    //The current position of the confetti
    private PVector position;
    //The current velocity of the confetti
    private PVector velocity;
    //Acceleration due to gravity
    private final PVector gravity = new PVector(0, 0.1f);
    //Terminal velocity, to stop the confetti from accelerating downward forever
    private final float terminalVelocity = 2.5f;

    //Radius of the confetti
    private final float radius = 8;
    
    //Color of the confetti
    private int confettiColor;

    public Confetti() {
        this.position = new PVector(screenCenter.x, 1048);

        float angle = radians(random(255, 285));
        this.velocity = PVector.fromAngle(angle).mult(random(11, 13));

        int[] colors = {0xFFFF0000, 0xFFA0FF00, 0xFF00FF00, 0xFF0000FF, 0xFFFF00FF};
        int index = (int) random(colors.length);
        this.confettiColor = colors[index];
    }

    /**
    * Move method
    * Moves the confetti based on its velocity and does physics calculations
    */
    public void move() {
        this.position.add(this.velocity);
        if(this.velocity.y < this.terminalVelocity) {
            this.velocity.add(this.gravity);
        }
    }

    /**
    * Draw method
    * Draws the confetti
    */
    public void draw() {
        fill(this.confettiColor);
        ellipse(this.position.x, this.position.y, this.radius, this.radius);
    }
}
/**
* Index 2D class
* Stores an index into a 2D array
*/
class Index2D {
    //Indecies
    public int i;
    public int j;

    public Index2D(int i, int j) {
        this.i = i;
        this.j = j;
    }

    /**
    * Move Up method
    * Moves the index up one row
    */
    public void moveUp() {
        this.i = max(this.i - 1, 0);
    }

    /**
    * Move Down method
    * Moves the index down one row
    */
    public void moveDown() {
        this.i++;
    }

    /**
    * Move Left method
    * Moves the index left one column
    */
    public void moveLeft() {
        this.j = max(this.j - 1, 0);
    }

    /**
    * Move Right method
    * Moves the index right one column
    */
    public void moveRight() {
        this.j++;
    }
}
/**
* Input Manger Class
* Stores all currently pressed keys and manages inputs
*/
static class InputManager {

    //List of currently held keys
    public static ArrayList<Integer> keys = new ArrayList<Integer>();

    //Buttons with special functions
    public static int selectButton = KeyEvent.VK_Z;
    public static int backButton = KeyEvent.VK_X;

    /**
    * Add Key method
    * Adds a key to the input manager
    * Must be called in keyPressed
    *
    * @param the key to be added
    */
    public static void addKey(int key) {
        if(!keys.contains(key)) {
            keys.add(key);
        }
    }

    /**
    * Remove Key method
    * Removes a key from the input manager
    * Must be called in keyRemoved
    *
    * @param the key to be added
    */
    public static void removeKey(int key) {
        keys.remove(keys.indexOf(key));
    }

    /**
    * Get Direction method
    * Returns the direction that is currently pressing on the arrow keys (including diagonals)
    * Value is 0-indexed starting from the right and increasing clockwise
    *
    * @return the direction being input on the arrow keys (0-index from right, increasing clockwise)
    */
    public static int getDirection() {
        if(keys.contains(KeyEvent.VK_RIGHT) && keys.contains(KeyEvent.VK_DOWN)) {
            return 1;
        } else if(keys.contains(KeyEvent.VK_LEFT) && keys.contains(KeyEvent.VK_DOWN)) {
            return 3;
        } else if(keys.contains(KeyEvent.VK_LEFT) && keys.contains(KeyEvent.VK_UP)) {
            return 5;
        } else if(keys.contains(KeyEvent.VK_RIGHT) && keys.contains(KeyEvent.VK_UP)) {
            return 7;
        } else if(keys.contains(KeyEvent.VK_RIGHT)) {
            return 0;
        } else if(keys.contains(KeyEvent.VK_DOWN)) {
            return 2;
        } else if(keys.contains(KeyEvent.VK_LEFT)) {
            return 4;
        } else if(keys.contains(KeyEvent.VK_UP)) {
            return 6;
        }

        return -1;
    }

    /**
    * Is Arcade Button method
    * Returns whether of not the key being pressed in one of the buttons on the arcade cabinet
    * (Buttons are assigned to ctrl, alt, space, shift, z, x, c, and 5)
    *
    * @return true if key is an arcade cabinet button, otherwise false
    */
    public static boolean isArcadeButton(int key) {
        return (key == KeyEvent.VK_CONTROL ||
                key == KeyEvent.VK_ALT ||
                key == KeyEvent.VK_SPACE ||
                key == KeyEvent.VK_SHIFT ||
                key == KeyEvent.VK_Z ||
                key == KeyEvent.VK_X ||
                key == KeyEvent.VK_C ||
                key == KeyEvent.VK_5);
    }
}
/**
* Menu class
* Stores and manages a group of buttons (menu)
*/
class Menu {
    //Grid of buttons in the menu
    private Button[][] buttons;

    //The currently selected button
    public Button selectedButton;

    //The index (row and column) of the currently selected button
    public Index2D selectedIndex;

    public Menu(Button[][] buttons) {
        this.buttons = buttons;
        this.selectedButton = buttons[0][0];
        this.selectedIndex = new Index2D(0, 0);
    }

    public Menu(Button[][] buttons, Index2D startingIndex) {
        this.buttons = buttons;
        this.selectedButton = buttons[startingIndex.i][startingIndex.j];
        this.selectedIndex = startingIndex;
    }

    /**
    * Change Selection method
    * Changes the selected button based on the given key
    *
    * @param The key code of the pressed key
    */
    public void changeSelection(int key) {
        //Try-catch to catch index out of bounds errors so I don't have to test for them in each case
        try {
            switch (key) {
                case KeyEvent.VK_RIGHT:
                    if(this.buttons[this.selectedIndex.i][this.selectedIndex.j + 1] != null) {
                        this.selectedIndex.moveRight();
                    }
                    break;

                case KeyEvent.VK_DOWN:
                    if(this.buttons[this.selectedIndex.i + 1][this.selectedIndex.j] != null) {
                        this.selectedIndex.moveDown();
                    }
                    break;

                case KeyEvent.VK_LEFT:
                    if(this.buttons[this.selectedIndex.i][this.selectedIndex.j - 1] != null) {
                        this.selectedIndex.moveLeft();
                    }
                    break;

                case KeyEvent.VK_UP:
                    if(this.buttons[this.selectedIndex.i - 1][this.selectedIndex.j] != null) {
                        this.selectedIndex.moveUp();
                    }
                    break;
            }
            this.selectedButton = this.buttons[this.selectedIndex.i][this.selectedIndex.j];
        } catch (Exception e) {

        }
    }

    /**
    * Draw method
    * Draws all buttons in the menu
    */
    public void draw() {
        for(int i = 0; i < this.buttons.length; i++) {
            for(int j = 0; j < this.buttons[i].length; j++) {
                if(this.buttons[i][j] != null) {
                    this.buttons[i][j].draw(i == selectedIndex.i && j == selectedIndex.j);
                }
            }
        }
    }
}
/**
* Note class
* Keeps track of and draws an individual note
*/
class Note {
    //Lane that the note is in (0-indexed from right, increments clockwise)
    private int lane;
    //Timing of the note (in beats)
    private float beat;

    //Position of the note on the screen
    public PVector position;

    Note(int lane, float beat) {
        this.lane = lane;
        this.beat = beat;
    }

    /**
    * Update method
    * Called in updateInputs
    */
    public void update() {
        this.position = new PVector(cos(radians(this.lane * 45)) * ((this.beat - Conductor.songPosition) * 200 + spinner.radius) + screenCenter.x,
                                    sin(radians(this.lane * 45)) * ((this.beat - Conductor.songPosition) * 200 + spinner.radius) + screenCenter.y);
    }

    /**
    * Draw method
    * Draws the note to the screen
    * Runs in draw()
    */
    public void draw() {
        float radius = dist(screenCenter.x, screenCenter.y, this.position.x, this.position.y);
        noFill();
        stroke(0xFF50FFFF);
        strokeWeight(10);
        arc(screenCenter.x, screenCenter.y, radius, radius, radians(-22.5f + (this.lane * 45) + 2.5f), radians(-22.5f + ((this.lane + 1) * 45) - 2.5f));
        stroke(0);
        strokeWeight(1);
    }
}
/**
* Scene class
* Stores data related to an in-game scene
*/
class Scene {
    //The name of the scene
    public String name;

    //Functions to be called for to update the scene
    private Runnable updateFunction; //Should be used for anything that needs to run every frame that doesn't involve displaying objects
    private Runnable drawFunction; //Should only be used for displaying objects
    private Runnable keyPressedFunction;
    private Runnable keyReleasedFunction;

    public Scene(String name, Runnable updateFunction, Runnable drawFunction) {
        this.name = name;
        this.updateFunction = updateFunction;
        this.drawFunction = drawFunction;
        this.keyPressedFunction = () -> {};
        this.keyReleasedFunction = () -> {};
    }

    public Scene(String name, Runnable updateFunction, Runnable drawFunction, Runnable keyPressedFunction) {
        this.name = name;
        this.updateFunction = updateFunction;
        this.drawFunction = drawFunction;
        this.keyPressedFunction = keyPressedFunction;
        this.keyReleasedFunction = () -> {};
    }

    public Scene(String name, Runnable updateFunction, Runnable drawFunction, Runnable keyPressedFunction, Runnable keyReleasedFunction) {
        this.name = name;
        this.updateFunction = updateFunction;
        this.drawFunction = drawFunction;
        this.keyPressedFunction = keyPressedFunction;
        this.keyReleasedFunction = keyPressedFunction;
    }

    /**
    * Update method
    * Calls the scene's update function
    * Should be called before the scene's draw method
    */
    public void update() {
        updateFunction.run();
    }

    /**
    * Draw method
    * Calls the scene's draw function
    * Should be called after the scene's update method
    */
    public void draw() {
        drawFunction.run();
    }

    /**
    * Key Pressed method
    * Calls the scene's key pressed function
    */
    public void keyPressed() {
        keyPressedFunction.run();
    }

    /**
    * Key Released method
    * Calls the scene's key released function
    */
    public void keyReleased() {
        keyReleasedFunction.run();
    }
}
/**
* Scene Manager class
* Stores and manages scenes
* DO NOT CREATE MORE THAN ONE INSTANCE OF THIS CLASS
* (Should be static, but processing doesn't like referencing variables or functions
* from the main file in static classes)
*
* I hate processing
*/
class SceneManager {
    //Scenes in the game
    //Filled in setup() because processing doesn't like initializing non-empty arrays for some reason
    //There's also the very real chance I'm an idiot and missed something obvious but I'm not messing with it now
    public Scene[] scenes;

    //Currently playing scene
    public Scene currentScene;

    public SceneManager(Scene[] scenes) {
        this.scenes = scenes;
        this.currentScene = scenes[0];
    }

    /**
    * Set Starting Scene method
    * Sets the current scene to the first scene in the list of scenes
    * Only required because the list of scenes is populated after the array is created
    * ONLY CALL THIS ONCE AT THE END OF SETUP
    */
    public void setStartingScene() {
        this.currentScene = scenes[0];
    }

    /**
    * Set Scene method
    * Sets the current scene to the scene with the given ID
    *
    * @param The ID of the scene to be set
    */
    public void setScene(int sceneID) {
        try{
            currentScene = scenes[sceneID];
        } catch(Exception e) {
            println("Error changing scenes: " + e);
        }
    }

    /**
    * Set Scene method
    * Sets the current scene to the scene with the given name
    *
    * @param The name of the scene to be set
    */
    public void setScene(String sceneName) {
        for(Scene scene : scenes) {
            if(scene.name == sceneName) {
                currentScene = scene;
                return;
            }
        }
        println("Error changing scenes: No scene with name " + sceneName);
    }
}
/**
* Song class
* Stores all data related to a song
*/
class Song {
    //Beats per minute
    public int bpm;
    //Time before the song actually starts in the audio file (to account for space required for metadata) (in seconds)
    public float offset;

    //Time to wait before starting the song (in beats)
    public float countIn;

    //Audio file associated with song
    public SoundFile songFile;
    //Chart associated with song
    public Note[] chart;

    //Name of song and artist (not currently used)
    public String title, artist;

    //Cover image for the song, to be displayed in song select menu
    public PImage cover;

    Song(int bpm, float offset, float countIn, SoundFile songFile, Note[] chart, String title, String artist, PImage cover) {
        this.bpm = bpm;
        this.offset = offset;
        this.countIn = countIn;
        this.songFile = songFile;
        this.chart = chart;
        this.title = title;
        this.artist = artist;
        this.cover = cover;
    }
}
/**
* Spinner class
* Handles displaying the central spinner that the player controls
*/
class Spinner {
    //The position of the center of the spinner
    private PVector position;
    //The radius of the spinner (in pixels)
    public float radius;

    //The colour of unselected segments of the spinner
    private int mainColor;
    //The colour of the selected segment of teh spinner
    private int selectedColor;

    //The currently selected segment of the spinner (0 is the east segment, increments clockwise from there)
    public int selectedSegment = 0;

    public Spinner() {
        position = screenCenter;
        radius = 80;
        mainColor = color(255, 150, 150);
        selectedColor = color(255, 150, 255);
    }

    /**
    * Update method
    * Updates the spinner
    */
    public void update() {
        selectedSegment = InputManager.getDirection();
    }

    /**
    * Draw method
    * Draws the spinner to the screen
    */
    public void draw() {
        for(int i = 0; i < 8; i++) {
            fill(mainColor);
            arc(position.x, position.y, radius + 20, radius + 20, radians(-22.5f + (i * 45)), radians(-22.5f + ((i + 1) * 45)), PIE);

            if(i == selectedSegment) {
                fill(selectedColor);
            }
            arc(position.x, position.y, radius, radius, radians(-22.5f + (i * 45)), radians(-22.5f + ((i + 1) * 45)), PIE);
        }
    }
}
/**
* Temporary Text class
* Stores and controls attributes related to text that should disappear within a set amount of time
*/
class TempText {
    //The position of the text
    private PVector position;
    //The text to be displayed
    private String text;
    //How many frames before the text should disappear
    public int timer;

    public TempText(PVector position, String text) {
        this.position = position;
        this.text = text;
        this.timer = 30;
    }
    
    public TempText(PVector position, String text, int duration) {
        this.position = position;
        this.text = text;
        this.timer = duration;
    }

    /**
    * Tick method
    * Decrements the timer
    */
    public void tick() {
        this.timer--;
    }

    /**
    * Draw method
    * Draw the text
    */
    public void draw() {
        textAlign(CENTER);
        textSize(12);
        fill(0);
        text(text, position.x, position.y);
        textSize(32);
    }
}


  public void settings() { size(1280, 1024); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Rhythm_Spinner" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}

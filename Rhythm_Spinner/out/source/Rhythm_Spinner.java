/* autogenerated by Processing revision 1293 on 2023-12-11 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.awt.event.KeyEvent;
import java.lang.Runnable;
import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Rhythm_Spinner extends PApplet {





final PVector screenCenter = new PVector(640, 512);


//Central spinner for rhythm game
Spinner spinner = new Spinner();

//Test song file
SoundFile testFile;
SoundFile topOfTheWaveFile;
SoundFile cloudsFile;
SoundFile tonightFile;
//Chart for test song
Note[] testChart;
Note[] topOfTheWaveChart;
Note[] cloudsChart;
Note[] tonightChart;
//Test song
Song testSong;

Song topOfTheWave;
Song clouds;
Song tonight;

float offset = 0;

float tolerance = 0.1f;

SceneManager sceneManager = new SceneManager(new Scene[2]);

Button[][] testMenuButtons = {{new Button(new PVector(screenCenter.x, screenCenter.y - 100), new PVector(100, 30), 0xFFFF9696, 0xFFFF96FF, "Test 1", () -> sceneManager.setScene(1))},
                              {new Button(new PVector(screenCenter.x, screenCenter.y), new PVector(100, 30), 0xFFFF9696, 0xFFFF96FF, "Test 2", () -> println("Other button pressed"))}};

Menu testMenu = new Menu(testMenuButtons);

Scene testScene = new Scene("Test-Scene", () -> {}, () -> testMenu.draw(), () -> {
    testMenu.changeSelection(keyCode);
    if(InputManager.isArcadeButton(keyCode)) {
        testMenu.selectedButton.press();
    }
});
Scene emptyScene = new Scene("Empty", () -> {}, () -> text("there is nothing here", screenCenter.x, screenCenter.y, 100, 100));

public void setup() {
    //Setup screen
    /* size commented out by preprocessor */;

    sceneManager.scenes[0] = testScene;
    sceneManager.scenes[1] = emptyScene;

    //Set shape display modes
    rectMode(CENTER);
    ellipseMode(RADIUS);
    textAlign(CENTER, CENTER);

    //Load sound files
    testFile = new SoundFile(this, "Test Song.wav");
    topOfTheWaveFile = new SoundFile(this, "Songs/Top-of-the-Wave-(Vlad-Gluschenko)/vlad-gluschenko-top-of-the-wave.wav");
    cloudsFile = new SoundFile(this, "Songs/Clouds-(MusicbyAden)/musicbyaden-clouds.wav");
    tonightFile = new SoundFile(this, "Songs/tonight-(Rexlambo)/rexlambo-tonight.wav");

    //Load charts
    JSONObject waveJSON = loadJSONObject("Songs/Top-of-the-Wave-(Vlad-Gluschenko)/chart.json");
    JSONObject cloudsJSON = loadJSONObject("Songs/Clouds-(MusicbyAden)/chart.json");
    JSONObject tonightJSON = loadJSONObject("Songs/tonight-(Rexlambo)/chart.json");
    
    topOfTheWaveChart = loadChartFromJSON(waveJSON);
    cloudsChart = loadChartFromJSON(cloudsJSON);
    tonightChart = loadChartFromJSON(tonightJSON);

    //Initialize songs
    topOfTheWave = new Song(126, -1.2f, 2.5f, topOfTheWaveFile, topOfTheWaveChart, "Top of the Wave", "Vlad Gluschenko");
    clouds = new Song(120, 0, 4, cloudsFile, cloudsChart, "Clouds", "MusicbyAden");
    tonight = new Song(128, 0.127f, 4, tonightFile, tonightChart, "tonight", "Rexlambo");

    Conductor.setSong(tonight);
    sceneManager.setStartingScene();
}

public void draw() {
    //Clear screen
    background(255);

    updateInputs();
    sceneManager.currentScene.update();

    //Draw spinner
    //spinner.draw();
    sceneManager.currentScene.draw();

    //Draw notes
    //for(Note note : Conductor.chart) {
    //    note.draw();
    //}
}

/**
* Update Inputs function
* For anything that want's to be run more than once a frame
* Function runs in draw and whenever inputs are updated (keyPressed() and keyReleased())
*/
public void updateInputs() {
    //Update objects
    //spinner.update();
    //Conductor.update();
    //Conductor.curTime = (float) millis() / 1000;
    //if(Conductor.chart != null) {
    //    for(Note note : Conductor.chart) {
    //        note.update();
    //    }
    //}

    //Remove missed notes
    //for(int i = 0; i < Conductor.chart.size(); i++) {
    //    while(true) {
    //        if(Conductor.chart.size() <= 0) {
    //            break;
    //        }
    //        if(Conductor.songPosition > Conductor.chart.get(i).beat + tolerance) {
    //            Conductor.chart.remove(i);
    //            println("Miss :.(");
    //        } else {
    //            break;
    //        }
    //    }
    //}
}

public void keyPressed() {
    //Update inputs
    InputManager.addKey(keyCode);
    updateInputs();
    sceneManager.currentScene.keyPressed();

    //If an arcade button is pressed, check if a note has been hit
    //if(InputManager.isArcadeButton(keyCode)) {
    //    for(int i = 0; i < Conductor.chart.size(); i++) {
    //        if(Conductor.chart.get(i).beat < Conductor.songPosition + tolerance &&
    //           Conductor.chart.get(i).beat > Conductor.songPosition - tolerance &&
    //           Conductor.chart.get(i).lane == spinner.selectedSegment) {
    //            Conductor.chart.remove(i);
    //            println("Hit!");
    //        }
    //    }
    //}

    //If space is pressed, start song (for debugging and testing only, will be removed in future)
    //if(keyCode == 32) {
    //    Conductor.playSong();
    //}
}

public void keyReleased() {
    //Update inputs
    InputManager.removeKey(keyCode);
    updateInputs();
    sceneManager.currentScene.keyReleased();
}

public Note[] loadChartFromJSON(JSONObject json) {
    JSONArray chart;
    try {
        chart = json.getJSONArray("chart");
    } catch(Exception e) {
        println("No chart");
        return null;
    }
    Note[] output = new Note[chart.size()];
    for(int i = 0; i < chart.size(); i++) {
        output[i] = new Note(chart.getJSONObject(i).getInt("lane"), chart.getJSONObject(i).getFloat("beat"));
    }
    return output;
}
class Button {
    private PVector position;
    private PVector size;
    private int baseColor;
    private int selectedColor;
    private String label;

    private Runnable onPressedFunction;

    public Button(PVector position, PVector size, int baseColor, int selectedColor, String label, Runnable onPressedFunction) {
        this.position = position;
        this.size = size;
        this.baseColor = baseColor;
        this.selectedColor = selectedColor;
        this.label = label;
        this.onPressedFunction = onPressedFunction;
    }

    public void draw(boolean selected) {
        if(selected) {
            fill(this.selectedColor);
        } else {
            fill(this.baseColor);
        }
        rect(this.position.x, this.position.y, this.size.x, this.size.y);
        fill(0);
        text(this.label, this.position.x, this.position.y, this.size.x, this.size.y);
    }

    public void press() {
        this.onPressedFunction.run();
    }
}
/**
* Conductor class
* Controls timing for rhythm elements
* Taken from https://www.reddit.com/r/gamedev/comments/2fxvk4/heres_a_quick_and_dirty_guide_i_just_wrote_how_to/
*/
static class Conductor {
    //Beat per minute of the song currently being played
    private static int bpm;
    //Length of a beat of the song currently being played (in seconds)
    private static float crotchet;
    //Time before the song actually starts in the audio file (to account for space required for metadata) (in seconds)
    private static float offset;

    private static float countIn;

    private static float startTime;

    //Position in the current song (in beats)
    public static float songPosition;
    //Audio file for the song currently being played
    private static SoundFile songFile;

    public static ArrayList<Note> chart = new ArrayList<Note>();

    private static boolean playing = false;

    public static float curTime;

    /**
    * Update method
    * Runs in updateInputs()
    */
    public static void update() {
        if(songFile != null) {
            if(playing && !songFile.isPlaying() && curTime - startTime > countIn * crotchet) {
                println(curTime - startTime);
                println(countIn * crotchet);
                songFile.play();
            }
            songPosition = (songFile.position() - offset) / crotchet;
        }
    }

    /**
    * Set Song method
    * Sets the current song being played
    *
    * @param song to be played
    */
    public static void setSong(Song song) {
        bpm = song.bpm;
        crotchet = (float) 60 / song.bpm;
        offset = song.offset;
        countIn = song.countIn;
        songFile = song.songFile;
        chart.clear();
        for(Note note : song.chart) {
            chart.add(note);
        }
    }

    public static void playSong() {
        if(!playing && songFile != null) {
            startTime = curTime;
            playing = true;
        }
    }
}
class Index2D {
    public int i;
    public int j;

    public Index2D(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public void moveUp() {
        this.i--;
    }

    public void moveDown() {
        this.i++;
    }

    public void moveLeft() {
        this.j--;
    }

    public void moveRight() {
        this.j++;
    }
}
/**
* Input Manger Class
* Stores all currently pressed keys and manages inputs
*/
static class InputManager {

    //List of currently held keys
    public static ArrayList<Integer> keys = new ArrayList<Integer>();

    /**
    * Add Key method
    * Adds a key to the input manager
    * Must be called in keyPressed
    *
    * @param the key to be added
    */
    public static void addKey(int key) {
        if(!keys.contains(key)) {
            keys.add(key);
        }
    }

    /**
    * Remove Key method
    * Removes a key from the input manager
    * Must be called in keyRemoved
    *
    * @param the key to be added
    */
    public static void removeKey(int key) {
        keys.remove(keys.indexOf(key));
    }

    /**
    * Get Direction method
    * Returns the direction that is currently pressing on the arrow keys (including diagonals)
    * Value is 0-indexed starting from the right and increasing clockwise
    *
    * @return the direction being input on the arrow keys (0-index from right, increasing clockwise)
    */
    public static int getDirection() {
        if(keys.contains(KeyEvent.VK_RIGHT) && keys.contains(KeyEvent.VK_DOWN)) {
            return 1;
        } else if(keys.contains(KeyEvent.VK_LEFT) && keys.contains(KeyEvent.VK_DOWN)) {
            return 3;
        } else if(keys.contains(KeyEvent.VK_LEFT) && keys.contains(KeyEvent.VK_UP)) {
            return 5;
        } else if(keys.contains(KeyEvent.VK_RIGHT) && keys.contains(KeyEvent.VK_UP)) {
            return 7;
        } else if(keys.contains(KeyEvent.VK_RIGHT)) {
            return 0;
        } else if(keys.contains(KeyEvent.VK_DOWN)) {
            return 2;
        } else if(keys.contains(KeyEvent.VK_LEFT)) {
            return 4;
        } else if(keys.contains(KeyEvent.VK_UP)) {
            return 6;
        }

        return -1;
    }

    /**
    * Is Arcade Button method
    * Returns whether of not the key being pressed in one of the buttons on the arcade cabinet
    * (Buttons are assigned to ctrl, alt, space, shift, z, x, c, and 5)
    *
    * @return true if key is an arcade cabinet button, otherwise false
    */
    public static boolean isArcadeButton(int key) {
        return (key == KeyEvent.VK_CONTROL ||
                key == KeyEvent.VK_ALT ||
                key == KeyEvent.VK_SPACE ||
                key == KeyEvent.VK_SHIFT ||
                key == KeyEvent.VK_Z ||
                key == KeyEvent.VK_X ||
                key == KeyEvent.VK_C ||
                key == KeyEvent.VK_5);
    }
}
class Menu {
    private Button[][] buttons;
    public Button selectedButton;
    private Index2D selectedIndex;

    public Menu(Button[][] buttons) {
        this.buttons = buttons;
        this.selectedButton = buttons[0][0];
        this.selectedIndex = new Index2D(0, 0);
    }

    public Menu(Button[][] buttons, Index2D startingIndex) {
        this.buttons = buttons;
        this.selectedButton = buttons[startingIndex.i][startingIndex.j];
        this.selectedIndex = startingIndex;
    }

    public void changeSelection(int key) {
        try {
            switch (key) {
                case KeyEvent.VK_RIGHT:
                    if(this.buttons[this.selectedIndex.i][this.selectedIndex.j + 1] != null) {
                        this.selectedIndex.moveRight();
                    }
                    break;

                case KeyEvent.VK_DOWN:
                    if(this.buttons[this.selectedIndex.i + 1][this.selectedIndex.j] != null) {
                        this.selectedIndex.moveDown();
                    }
                    break;

                case KeyEvent.VK_LEFT:
                    if(this.buttons[this.selectedIndex.i][this.selectedIndex.j - 1] != null) {
                        this.selectedIndex.moveLeft();
                    }
                    break;

                case KeyEvent.VK_UP:
                    if(this.buttons[this.selectedIndex.i - 1][this.selectedIndex.j] != null) {
                        this.selectedIndex.moveUp();
                    }
                    break;
            }
            this.selectedButton = this.buttons[this.selectedIndex.i][this.selectedIndex.j];
        } catch (Exception e) {

        }
    }

    public void draw() {
        for(int i = 0; i < this.buttons.length; i++) {
            for(int j = 0; j < this.buttons[i].length; j++) {
                if(this.buttons[i][j] != null) {
                    this.buttons[i][j].draw(i == selectedIndex.i && j == selectedIndex.j);
                }
            }
        }
    }
}
/**
* Note class
* Keeps track of and draws an individual note
*/
class Note {
    //Lane that the note is in (0-indexed from right, increments clockwise)
    private int lane;
    //Timing of the note (in beats)
    private float beat;

    //Position of the note on the screen
    public PVector position;

    Note(int lane, float beat) {
        this.lane = lane;
        this.beat = beat;
    }

    /**
    * Update method
    * Called in updateInputs
    */
    public void update() {
        this.position = new PVector(sin(radians(this.lane * 45)) * ((this.beat - Conductor.songPosition) * 200 + spinner.radius - offset) + 640,
                                    cos(radians(this.lane * 45)) * ((this.beat - Conductor.songPosition) * 200 + spinner.radius - offset) + 512);
    }

    /**
    * Draw method
    * Draws the note to the screen
    * Runs in draw()
    */
    public void draw() {
        float radius = dist(screenCenter.x, screenCenter.y, this.position.x, this.position.y);
        noFill();
        arc(screenCenter.x, screenCenter.y, radius, radius, radians(-22.5f + (this.lane * 45)), radians(-22.5f + ((this.lane + 1) * 45)));
    }
}
class Scene {
    public String name;

    private Runnable updateFunction;
    private Runnable drawFunction;
    private Runnable keyPressedFunction;
    private Runnable keyReleasedFunction;

    public Scene(String name, Runnable updateFunction, Runnable drawFunction) {
        this.name = name;
        this.updateFunction = updateFunction;
        this.drawFunction = drawFunction;
        this.keyPressedFunction = () -> {};
        this.keyReleasedFunction = () -> {};
    }

    public Scene(String name, Runnable updateFunction, Runnable drawFunction, Runnable keyPressedFunction) {
        this.name = name;
        this.updateFunction = updateFunction;
        this.drawFunction = drawFunction;
        this.keyPressedFunction = keyPressedFunction;
        this.keyReleasedFunction = () -> {};
    }

    public Scene(String name, Runnable updateFunction, Runnable drawFunction, Runnable keyPressedFunction, Runnable keyReleasedFunction) {
        this.name = name;
        this.updateFunction = updateFunction;
        this.drawFunction = drawFunction;
        this.keyPressedFunction = keyPressedFunction;
        this.keyReleasedFunction = keyPressedFunction;
    }

    public void update() {
        updateFunction.run();
    }

    public void draw() {
        drawFunction.run();
    }

    public void keyPressed() {
        keyPressedFunction.run();
    }

    public void keyReleased() {
        keyReleasedFunction.run();
    }
}
class SceneManager {
    public Scene[] scenes;

    public Scene currentScene;

    public SceneManager(Scene[] scenes) {
        this.scenes = scenes;
        this.currentScene = scenes[0];
    }

    public void setStartingScene() {
        this.currentScene = scenes[0];
    }

    public void setScene(int sceneID) {
        try{
            currentScene = scenes[sceneID];
        } catch(Exception e) {
            println("Error changing scenes: " + e);
        }
    }

    public void setScene(String sceneName) {
        for(Scene scene : scenes) {
            if(scene.name == sceneName) {
                currentScene = scene;
                return;
            }
        }
        println("Error changing scenes: No scene with name " + sceneName);
    }
}
/**
* Song class
* Stores all data related to a song
*/
class Song {
    //Beats per minute
    public int bpm;
    //Time before the song actually starts in the audio file (to account for space required for metadata) (in seconds)
    public float offset;

    public float countIn;

    //Audio file associated with song
    public SoundFile songFile;
    //Chart associated with song
    public Note[] chart;

    //Name of song and artist (not currently used)
    public String title, artist;

    Song(int bpm, float offset, float countIn, SoundFile songFile, Note[] chart, String title, String artist) {
        this.bpm = bpm;
        this.offset = offset;
        this.countIn = countIn;
        this.songFile = songFile;
        this.chart = chart;
        this.title = title;
        this.artist = artist;
    }
}
/**
* Spinner class
* Handles displaying the central spinner that the player controls
*/
class Spinner {
    //The position of the center of the spinner
    private PVector position;
    //The radius of the spinner (in pixels)
    public float radius;

    //The colour of unselected segments of the spinner
    private int mainColor;
    //The colour of the selected segment of teh spinner
    private int selectedColor;

    //The currently selected segment of the spinner (0 is the east segment, increments clockwise from there)
    public int selectedSegment = 0;

    public Spinner() {
        position = screenCenter;
        radius = 80;
        mainColor = color(255, 150, 150);
        selectedColor = color(255, 150, 255);
    }

    /**
    * Update method
    * Runs in updateInputs()
    */
    public void update() {
        selectedSegment = InputManager.getDirection();
    }

    /**
    * Draw method
    * Draws the spinner to the screen
    * Runs in draw()
    */
    public void draw() {
        for(int i = 0; i < 8; i++) {
            if(i == selectedSegment) {
                fill(selectedColor);
            } else {
                fill(mainColor);
            }

            arc(position.x, position.y, radius, radius, radians(-22.5f + (i * 45)), radians(-22.5f + ((i + 1) * 45)), PIE);
        }
    }
}


  public void settings() { size(1280, 1024); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Rhythm_Spinner" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
